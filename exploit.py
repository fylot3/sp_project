#! /usr/bin/env python3

import os
import sys
import hmac
import hashlib
import socket
import random

from Crypto.Hash import SHA256
from Crypto.Cipher import AES
from Crypto.PublicKey import RSA
from Crypto.Util.Padding import pad, unpad
from Crypto.Signature.pkcs1_15 import PKCS115_SigScheme

from donna25519 import PrivateKey, PublicKey
from binascii import hexlify, unhexlify


def compute_mac(key, data):
    return hmac.new(key, data, digestmod=hashlib.sha256).digest()

def is_valid_mac(key, data, mac):
    return hmac.compare_digest(compute_mac(key, data), mac)

def AES_encrypt(key, message, iv=None):
    cipher = AES.new(key, AES.MODE_CBC, iv=iv)
    return cipher.encrypt(pad(message, AES.block_size))

def AES_decrypt(key, message, iv=None):
    cipher = AES.new(key, AES.MODE_CBC, iv=iv)
    return unpad(cipher.decrypt(message), AES.block_size)

def increment_iv(iv):
    return iv

def convert_int_to_bin_hex_le(n, pad_size):
    res = hex(n)[2:]
    if res[-1] == 'L':
        res = res[:-1]
    res = "0" * (2 * pad_size - len(res)) + res # pad
    res = unhexlify(res)[::-1] # LE
    return res


# Send/Receive/Connect

def send_msg(s, data):
    s.send(hexlify(data) + b'\n')

def receive_msg(s):
    data = b''

    while not data.endswith(b'\n'):
        byte = s.recv(1)
        if byte == b'':
            return data
        data += byte

    # print(data)
    return unhexlify(data[:-1])

def connect(target):
    IP_ADDR = "127.0.0.1"
    PORT = 8000
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((IP_ADDR, PORT))
    s.send(target + b'\n')

    return s


def get_auth_pub25519_zero_key():
    # Server RSA key
    server_n = "cba385be9dd86d73605581617a5c14aa04efc66bd4a3173bca2391e543e6aebb62553f911469f97cca4cfe6e633407915e12fba075e2a9aaf068775150452199c189d2280ed1edd67fb2043ee22df4ede2fa2439f0f739e2abff6385f533ebb2fca59cc86c6551cfcb8317c0e0000000000000000000000000000000000136d1"
    server_e = "03"
    server_d = "87c25929be9048f7958e5640fc3d631c034a8447e31764d286c261438299c9d2418e2a60b846a6533188a99eeccd5a60e961fd15a3ec711ca045a4e0e02e16654f882d27095983de76c269a9f46bae857a8e8140f8eab226551fdfb139bdc0d07dde55de595b02bb90d8bc914aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab784b"
    rsa_components = (int(server_n, 16), int(server_e, 16), int(server_d, 16))
    server_key = RSA.construct(rsa_components, consistency_check=True)

    # Public keys on 25519 curve yielding the same shared secret in DH
    # Choose one of them as the public key in DH (first 2 are filtered in validation)
    pub25519_zero_keys = [
        0,
        1,
        325606250916557431795983626356110631294008115727848805560023387167927233504,
        39382357235489614581723060781553021112529911719440698176882885853963445705823,
        2**255 - 19 - 1,
        2**255 - 19,
        2**255 - 19 + 1,

        # 2**255 - 19 + 325606250916557431795983626356110631294008115727848805560023387167927233504,
        # 2**255 - 19 + 39382357235489614581723060781553021112529911719440698176882885853963445705823,
        # 2*(2**255 - 19) - 1,
        # 2*(2**255 - 19),
        # 2*(2**255 - 19) + 1
    ]
    pub25519_key = random.choice(pub25519_zero_keys[2:])
    pub25519_key = convert_int_to_bin_hex_le(pub25519_key, 32)

    # Authenticate the chosen public key with the server RSA key
    signature = PKCS115_SigScheme(server_key).sign(SHA256.new(pub25519_key))

    return pub25519_key, signature


CLIENT = b'c'
SERVER = b's'

if __name__ == "__main__":
    # Get an authenticated pbulic key on 25519 Curve yielding same SS when used for DH
    my_pub25519, my_signature = get_auth_pub25519_zero_key()

    # Connect to the Server and Client
    s_client = connect(CLIENT)
    s_server = connect(SERVER)

    #
    # Server - get public key, nonce and signature
    #
    server_pub = receive_msg(s_server)
    server_nonce = receive_msg(s_server)
    server_signature = receive_msg(s_server)

    #
    # Client - get public key and nonce
    #
    client_pub = receive_msg(s_client)
    client_nonce = receive_msg(s_client)

    #
    # Server - send chosen pub key and client's nonce
    #
    send_msg(s_server, my_pub25519)
    send_msg(s_server, client_nonce)

    #
    # Client - send chosen pub key, authenticated and server's nonce
    #
    send_msg(s_client, my_pub25519)
    send_msg(s_client, server_nonce)
    send_msg(s_client, my_signature)

    #
    # Server/Client - exchange the macs between Server and Client
    #
    server_mac = receive_msg(s_server)
    client_mac = receive_msg(s_client)
    send_msg(s_server, client_mac)
    send_msg(s_client, server_mac)

    # Compute the shared secret and ivs used for communication with the server
    shared_key = PrivateKey().do_exchange(PublicKey(my_pub25519))
    server_iv = server_nonce[:16]
    client_iv = client_nonce[:16]

    # Server should send a message - AUHTENTICATED
    ciphertext = receive_msg(s_server)
    msg = AES_decrypt(shared_key, ciphertext, server_iv)
    increment_iv(server_iv)
    print(msg)
