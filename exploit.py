#! /usr/bin/env python3

import os
import sys
import hmac
import hashlib
import socket
import random

from Crypto.Hash import SHA256
from Crypto.Cipher import AES
from Crypto.PublicKey import RSA
from Crypto.Util.Padding import pad, unpad
from Crypto.Signature.pkcs1_15 import PKCS115_SigScheme

from donna25519 import PrivateKey, PublicKey
from binascii import hexlify, unhexlify

def trunc(data):
    dt = ''.join([str(f'{ch:02x}') for ch in data])
    return '[' + dt[:64] + '..]' if len(dt) > 64 else '[' + dt + ']'

def compute_mac(key, data):
    return hmac.new(key, data, digestmod=hashlib.sha256).digest()

def is_valid_mac(key, data, mac):
    return hmac.compare_digest(compute_mac(key, data), mac)

def AES_encrypt(key, message, iv=None):
    cipher = AES.new(key, AES.MODE_CBC, iv=iv)
    return cipher.encrypt(pad(message, AES.block_size))

def AES_decrypt(key, message, iv=None):
    cipher = AES.new(key, AES.MODE_CBC, iv=iv)
    return unpad(cipher.decrypt(message), AES.block_size)

def increment_iv(iv):
    return iv

def convert_int_to_bin_hex_le(n, pad_size):
    res = hex(n)[2:]
    if res[-1] == 'L':
        res = res[:-1]
    res = "0" * (2 * pad_size - len(res)) + res # pad
    res = unhexlify(res)[::-1] # LE
    return res


# Send/Receive/Connect

def send_msg(s, data):
    s.send(hexlify(data) + b'\n')

def receive_msg(s):
    data = b''

    while not data.endswith(b'\n'):
        byte = s.recv(1)
        if byte == b'':
            return data
        data += byte

    # print(data)
    return unhexlify(data[:-1])

def connect(target):
    IP_ADDR = "127.0.0.1"
    PORT = 8000
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((IP_ADDR, PORT))
    s.send(target + b'\n')

    return s


def get_auth_pub25519_zero_key():
    # Server RSA key
    server_n = "cba385be9dd86d73605581617a5c14aa04efc66bd4a3173bca2391e543e6aebb62553f911469f97cca4cfe6e633407915e12fba075e2a9aaf068775150452199c189d2280ed1edd67fb2043ee22df4ede2fa2439f0f739e2abff6385f533ebb2fca59cc86c6551cfcb8317c0e0000000000000000000000000000000000136d1"
    server_e = "03"
    server_d = "87c25929be9048f7958e5640fc3d631c034a8447e31764d286c261438299c9d2418e2a60b846a6533188a99eeccd5a60e961fd15a3ec711ca045a4e0e02e16654f882d27095983de76c269a9f46bae857a8e8140f8eab226551fdfb139bdc0d07dde55de595b02bb90d8bc914aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab784b"
    rsa_components = (int(server_n, 16), int(server_e, 16), int(server_d, 16))
    server_key = RSA.construct(rsa_components, consistency_check=True)

    # Public keys on 25519 curve yielding the same shared secret in DH
    # Choose one of them as the public key in DH (first 2 are filtered in validation)
    pub25519_zero_keys = [
        0,
        1,
        325606250916557431795983626356110631294008115727848805560023387167927233504,
        39382357235489614581723060781553021112529911719440698176882885853963445705823,
        2**255 - 19 - 1,
        2**255 - 19,
        2**255 - 19 + 1,

        # 2**255 - 19 + 325606250916557431795983626356110631294008115727848805560023387167927233504,
        # 2**255 - 19 + 39382357235489614581723060781553021112529911719440698176882885853963445705823,
        # 2*(2**255 - 19) - 1,
        # 2*(2**255 - 19),
        # 2*(2**255 - 19) + 1
    ]
    pub25519_key = random.choice(pub25519_zero_keys[2:])
    pub25519_key = convert_int_to_bin_hex_le(pub25519_key, 32)

    # Authenticate the chosen public key with the server RSA key
    signature = PKCS115_SigScheme(server_key).sign(SHA256.new(pub25519_key))

    return pub25519_key, signature


CLIENT = b'c'
SERVER = b's'

if __name__ == "__main__":
    # Get an authenticated pbulic key on 25519 Curve yielding same SS when used for DH
    print("Get an authenticated pbulic key on 25519 Curve yielding same SS when used for DH")
    print("Calculate signature over calculated key using server's RSA cracked key")
    input()
    my_pub25519, my_signature = get_auth_pub25519_zero_key()

    print(f'ATT       : my_pub25519      = {trunc(my_pub25519)}')
    print(f'ATT       : my_signature     = {trunc(my_signature)}')

    # Connect to the Server and Client
    print('Connecting to CLIENT ...')
    s_client = connect(CLIENT)
    print('Connected to CLIENT')
    print('Connecting to SERVER ...')
    s_server = connect(SERVER)
    print('Connected to SERVER')
    print()

    #
    # Server - get public key, nonce and signature
    #
    print("Server - get public key, nonce and signature")
    input()
    server_pub = receive_msg(s_server)
    server_nonce = receive_msg(s_server)
    server_signature = receive_msg(s_server)
    print(f'  S -> ATT: server_pub       = {trunc(server_pub)}')
    print(f'  S -> ATT: server_nonce     = {trunc(server_nonce)}')
    print(f'  S -> ATT: server_signature = {trunc(server_signature)}')
    print()

    #
    # Client - get public key and nonce
    #
    print("Client - get public key and nonce")
    input()
    client_pub = receive_msg(s_client)
    client_nonce = receive_msg(s_client)
    print(f'  C -> ATT: client_pub       = {trunc(client_pub)}')
    print(f'  C -> ATT: client_nonce     = {trunc(client_nonce)}')
    print()

    #
    # Server - send chosen pub key and client's nonce
    #
    print("Server - send chosen pub key and client's nonce")
    input()
    send_msg(s_server, my_pub25519)
    send_msg(s_server, client_nonce)
    print(f'ATT ->   S: my_pub25519      = {trunc(my_pub25519)}')
    print(f'ATT ->   S: client_nonce     = {trunc(client_nonce)}')
    print()

    #
    # Client - send chosen pub key, authenticated and server's nonce
    #
    print("Client - send chosen pub key, authenticated and server's nonce")
    input()
    send_msg(s_client, my_pub25519)
    send_msg(s_client, server_nonce)
    send_msg(s_client, my_signature)
    print(f'ATT ->   C: my_pub25519      = {trunc(my_pub25519)}')
    print(f'ATT ->   C: server_nonce     = {trunc(server_nonce)}')
    print(f'ATT ->   C: my_signature     = {trunc(my_signature)}')
    print()

    #
    # Server/Client - exchange the macs between Server and Client
    #
    print("Server/Client - exchange the macs between Server and Client")
    input()
    server_mac = receive_msg(s_server)
    print(f'  S -> ATT: server_mac      = {trunc(server_mac)}')
    client_mac = receive_msg(s_client)
    print(f'  C -> ATT: client_mac      = {trunc(client_mac)}')

    send_msg(s_server, client_mac)
    print(f'ATT ->   S: client_mac      = {trunc(client_mac)}')
    send_msg(s_client, server_mac)
    print(f'ATT ->   C: server_mac      = {trunc(server_mac)}')

    # Compute the shared secret and ivs used for communication with the server
    print("Compute the shared secret and ivs used for communication with the server")
    input()
    shared_key = PrivateKey().do_exchange(PublicKey(my_pub25519))
    print(f'ATT       : shared_key      = {trunc(shared_key)}')
    print()
    server_iv = server_nonce[:16]
    client_iv = client_nonce[:16]

    # Server should send a message - AUHTENTICATED
    print("Server should send a message - AUHTENTICATED")
    input()
    ciphertext = receive_msg(s_server)
    print(f'  S -> ATT: ciphertext      = {trunc(ciphertext)}')
    print()
    msg = AES_decrypt(shared_key, ciphertext, server_iv)
    increment_iv(server_iv)
    print(f'ATT       : message         = {trunc(msg)}')

